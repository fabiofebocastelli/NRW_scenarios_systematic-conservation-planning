# Scenario 1 

library(prioritizr)
library(sf)
library(terra)
library(vegan)
library(cluster)
library(raster)
library(gurobi)
library(slam)


# load planning unit data
tfc_costs <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/u2018_clc2018_v2020_20u1_geoPackage/total_forest_cover_25832.tif")
tfc_costs

# creating a new raster with constant costs
tfc_const_costs <- (tfc_costs*0) + 1
tfc_const_costs

# print number of planning units
number_of_planning_units(p1)

# loading conservation features
existing_spa <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Forest strictly protected/Forest_strictly_protected_25832_revised.tif")
N2000 <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Occurrence of FFH habitat types in North Rhine-Westphalia/Habitat_directive_FFH_25832.tif")
fht <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Habitat_types_AnnexI/Dataset_from_Lanuv/forest_habitat_types_reclas_25832.tif") 
pwa <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Potential wilderness areas/PWA_3000_NRW_25832.tif")
state_f <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Public forest/State_forest_25832.tif")
# update values in tfc feature
tfc_feature <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/u2018_clc2018_v2020_20u1_geoPackage/total_forest_cover_25832.tif")
tfc_feature <- terra::mask(
  tfc_feature,
  mask = (tfc_feature > 0.5) & (vit_dec == 0.25),
  maskvalues = 1,
  updatevalue = 0.25
)
names(tfc_feature) <- "tfc_feature"

# create a binary stack for fht raster
bstacked_fht <- binary_stack(fht) 

# I want to prioritize the cells corresponding to ecologically valuable forests --> cells with not highly damaged forest should have higher values in order
# to be selected in the cheapest solution when a fixed budget has been set. 

# loading the high vitality decreased layer
vit_dec <- rast("C:/Users/Fabio Castelli/OneDrive - Alma Mater Studiorum Università di Bologna/Desktop/NRW_Data/Vitality Decrease/vitality_highly_decreased_25832.tif")
# setting value 0.25 for all the cells
reclass_matrix <- matrix(c(3, 0.25), ncol = 2, byrow = TRUE)
vit_dec <-  classify(vit_dec, reclass_matrix)


# set names to keep track of all the different fht
names(bstacked_fht) <- paste0("class_", seq_len(nlyr(bstacked_fht)))

# remove layers with only zeros
bstacked_fht <- bstacked_fht[[which(global(bstacked_fht, "max", na.rm = TRUE)[[1]] > 0.5)]]   

# I need to change bstacked_fht layers values in this way: WHEN 'NULL' THEN 'NULL'; WHEN '0' THEN '0'; WHEN '1'THEN '1' IF not overlap with vit_dec
# or '0.25' IF overlap with vit_dec
# or in other words, replace the values only when bstacked_fht[[i]] > 0.5 and vit_dec > 0.20
# but maybe this is not possible in a binary stacked raster where only binary values are possible.. then how?

# trying this way:
modified_bstacked_fht <-  terra::rast(lapply(as.list(bstacked_fht), function(x) {
  terra::mask(x, mask = (x > 0.5) & (vit_dec == 0.25), maskvalues = 1, updatevalue = 0.25)
}))


# making space for such a big plot
windows(width = 10, height = 8) 

# plotting fht binary stacked just to give a look
par(mfrow = c(5, 6))

for (i in 1:25) {
     layer <- modified_bstacked_fht[[i]]  # current layer extraction
     layer_name <- names(modified_bstacked_fht)[i]  # current layer's name extraction
     plot(layer, main = layer_name)}  

cons_feat_1 <- c(modified_bstacked_fht, existing_spa, pwa, state_f, N2000, tfc_feature)
cons_feat_1



# calculating the area of existing SPAs so we can include it in the linear constraints
freq(existing_spa) # 29606


# Add targets

# setting different relative targets
wild_targets <- c(
  rep(0, nlyr(modified_bstacked_fht)), ## >= =% coverage of each forest type
  0,                                     ## >= 0% coverage of existing_spa
  0,                                     ## >= 0% coverage of pwa
  0,                                     ## >= 0% coverage of state_f
  0,                                    ## >= 0% coverage of N2000
  0                                    ## tfc_feature, should it be 1, or 0 ?
)


bd <- rescale_matrix(boundary_matrix(tfc_const_costs))




# Add constraints

# preparing data
# not_state_f <- as.int(state_f < 0.5) # this is not working, it gives me the same raster..
# trying to get the not_state_forest layer by subtraction between total forest cover and state forest. I need to change the NA values to 0
tfc_const_costs[is.na(tfc_const_costs)] <- 0 # reclassifying total forest cover layer
state_f[is.na(state_f)] <- 0 # reclassifying state layer
not_state_f <- tfc_const_costs - state_f



p1.b <-
  problem(tfc_const_costs * 0, cons_feat_1) %>%
  add_boundary_penalties(penalty = 1, data = bd) %>%
  add_min_set_objective() %>%
  add_linear_constraints(
    threshold = 90092,
    sense = "=",
    data = tfc_const_costs) %>%
  add_relative_targets(wild_targets) %>%
  add_locked_out_constraints(not_state_f) %>%
  add_locked_in_constraints(pwa) %>%
  add_locked_in_constraints(existing_spa) %>%
  add_gurobi_solver(gap = 0)

#trial
# togliendo solo add_locked_out_constraints(not_state_f) mi da lo stesso errore
# togliendo solo  add_locked_in_constraints(pwa) %>% add_locked_in_constraints(existing_spa) funziona
# abbassando la penalty a 0.1 mi da lo stesso errore 
# cambiando in add_linear_constraints(threshold = 90092,sense = "=",data = tfc_feature) mi da lo stesso errore 
# con threshold =10000 mi da lo stesso errore
# togliendo solo add_locked_in_constraints(existing_spa) funziona
# inserendo add_locked_out_constraints(existing_spa)

p1.b <-
  problem(tfc_const_costs * 0, cons_feat_1) %>%
  add_boundary_penalties(penalty = 1, data = bd) %>%
  add_min_set_objective() %>%
  add_linear_constraints(
    threshold = 90092,
    sense = "=",
    data = tfc_const_costs) %>%
  add_relative_targets(wild_targets) %>%
  add_locked_out_constraints(not_state_f) %>%
  add_locked_out_constraints(existing_spa) %>%
  add_locked_in_constraints(pwa) %>%
  add_gurobi_solver(gap = 0)

# solving with Gurobi

s1.b <- solve(p1.b, force = TRUE)


plot(s1.b)

# evaluating the solution

# calculate statistic 
# cost summary
eval_cost_summary(p1.b, s1.b)

# Feature representation summary
eval_feature_representation_summary(p1.b, s1.b)

# Target coverage summary
# calculate statistics
eval_target_coverage_summary(p1.b, s1.b)

